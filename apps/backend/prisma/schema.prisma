generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ------------------------------
// USER AUTHENTICATION & TENANCY (Multi-Tenant Model)
// ------------------------------
model User {
  id                         String       @id @default(uuid())
  email                      String       @unique
  passwordHash               String
  name                       String?
  twofaSecret                String?
  createdAt                  DateTime     @default(now())
  updatedAt                  DateTime     @updatedAt

  // Relations
  passwordResetTokens        PasswordResetToken[]
  sessions                   Session[]
  refreshTokens              RefreshToken[]
  orgMembers                 OrgMember[]
  auditLogs                  AuditLog[]       @relation("AuditLogActor")
  integrationsInstalled      Integration[]    @relation("IntegrationInstalledBy")
  teamMembers                TeamMember[]     @relation("TeamMemberUser")
  createdTeams               Team[]           @relation("TeamCreatedBy")
  addedTeamMembers           TeamMember[]     @relation("TeamMemberAddedBy")
  createdStandupConfigs      StandupConfig[]  @relation("StandupConfigCreatedBy")
}

model PasswordResetToken {
  token     String   @id @default(uuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  expiresAt DateTime

  @@index([token])
}

model Session {
  id          String   @id @default(uuid())
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  issuedAt    DateTime @default(now())
  lastSeenIp  String?
  revokedAt   DateTime?
}

/// Refresh tokens for rotation, anomaly detection, and per-device session control
model RefreshToken {
  id          String   @id @default(uuid())
  token       String   @unique
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  createdAt   DateTime @default(now())
  lastUsedAt  DateTime?
  revokedAt   DateTime?
  fingerprint String
  ipAddress   String

  @@index([userId, createdAt])
}

model Organization {
  id               String           @id @default(uuid())
  name             String?

  // Relations
  billingAccount   BillingAccount?
  members          OrgMember[]
  integrations     Integration[]
  teams            Team[]
  auditLogs        AuditLog[]
}

enum OrgRole {
  owner
  admin
  member
}

enum OrgMemberStatus {
  invited
  active
  suspended
}

model OrgMember {
  org          Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  orgId        String
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId       String
  role         OrgRole
  status       OrgMemberStatus
  inviteToken  String?      @unique
  invitedAt    DateTime?
  acceptedAt   DateTime?

  @@id([orgId, userId])
  @@unique([orgId, userId])
  @@index([inviteToken])
}

model AuditLog {
  id                    String       @id @default(uuid())
  org                   Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  orgId                 String
  actorUser             User?        @relation("AuditLogActor", fields: [actorUserId], references: [id])
  actorUserId           String?
  actorPlatformUserId   String?
  actorType             String       @default("user") // user, system, api_key, service
  
  // Event classification
  action                String
  category              String       // auth, user_management, data_modification, system, integration, billing
  severity              String       // low, medium, high, critical
  
  // Request/Response data
  requestData           Json?        // Method, path, body, query, headers, userAgent, ipAddress
  responseData          Json?        // StatusCode, body, executionTime
  
  // Resource tracking
  resources             Json?        // Array of affected resources with before/after values
  
  // Enhanced metadata
  sessionId             String?
  correlationId         String?
  tags                  String[]     @default([])
  executionTime         Int?         // Milliseconds
  
  // Legacy payload field (for backward compatibility)
  payload               Json?
  
  createdAt             DateTime     @default(now())

  @@index([orgId, createdAt])
  @@index([orgId, category, createdAt])
  @@index([orgId, severity, createdAt])
  @@index([orgId, actorUserId, createdAt])
  @@index([correlationId])
  @@index([sessionId])
}

// ------------------------------
// EXTERNAL PLATFORM INTEGRATIONS
// ------------------------------
enum IntegrationPlatform {
  slack
  teams
}

enum TokenStatus {
  ok
  expired
  revoked
}

model Integration {
  id                String        @id @default(uuid())
  org               Organization  @relation(fields: [orgId], references: [id], onDelete: Cascade)
  orgId             String
  platform          IntegrationPlatform
  externalTeamId    String
  accessToken       String
  refreshToken      String?
  expiresAt         DateTime?
  tokenStatus       TokenStatus
  scopes            String[]      // Bot scopes granted to the bot token
  userScopes        String[]      @default([]) // User scopes granted to the user token
  installedBy       User?         @relation("IntegrationInstalledBy", fields: [installedByUserId], references: [id], onDelete: SetNull)
  installedByUserId String?
  
  // Slack-specific OAuth v2 fields
  botToken          String?
  botUserId         String?
  appId             String?

  // Relations
  teams             Team[]
  channels          Channel[]
  integrationUsers  IntegrationUser[]
  syncState         IntegrationSyncState?
  digestPosts       StandupDigestPost[]
  tokenRefreshJobs  TokenRefreshJob[]

  @@unique([orgId, platform, externalTeamId])
  @@index([tokenStatus])
}

model IntegrationSyncState {
  integration        Integration @relation(fields: [integrationId], references: [id], onDelete: Cascade)
  integrationId      String      @id
  lastUsersSyncAt    DateTime?
  lastChannelsSyncAt DateTime?
  errorMsg           String?
}

// ------------------------------
// STANDUP FEATURE DOMAINS
// ------------------------------
model Channel {
  id             String       @id @default(uuid())
  integration    Integration  @relation(fields: [integrationId], references: [id], onDelete: Cascade)
  integrationId  String
  channelId      String       // Slack channel ID (e.g., C1234567890)
  name           String       // Channel name (e.g., engineering)
  topic          String?      // Channel topic/description
  purpose        String?      // Channel purpose
  isPrivate      Boolean      @default(false)
  isArchived     Boolean      @default(false)
  memberCount    Int?         // Number of members in channel
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  lastSyncAt     DateTime?    // When channel info was last synced

  // Relations
  teams          Team[]       // Teams assigned to this channel

  @@unique([integrationId, channelId])
  @@index([integrationId, isArchived])
  @@index([name])
}

model IntegrationUser {
  id              String      @id @default(uuid())
  integration     Integration @relation(fields: [integrationId], references: [id], onDelete: Cascade)
  integrationId   String
  
  // Generic fields that work for all platforms (Slack, Teams, Discord, etc.)
  externalUserId  String      // Slack ID, Teams ID, Discord ID, etc.
  name            String?
  displayName     String?
  email           String?
  isBot           Boolean     @default(false)
  isDeleted       Boolean     @default(false)
  profileImage    String?
  timezone        String?
  
  // Platform-specific data stored as JSON
  platformData    Json?       // Store platform-specific fields here
  
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  lastSyncAt      DateTime?

  // Relations
  teamMembers     TeamMember[] @relation("IntegrationUserTeamMember")

  @@unique([integrationId, externalUserId])
  @@index([integrationId, isDeleted])
  @@index([integrationId, externalUserId])
}

model Team {
  id             String       @id @default(uuid())
  org            Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  orgId          String
  integration    Integration  @relation(fields: [integrationId], references: [id], onDelete: Cascade)
  integrationId  String
  channel        Channel?     @relation(fields: [channelId], references: [id], onDelete: SetNull)
  channelId      String?      // Now references Channel.id, not Slack channel ID
  slackChannelId String       // The actual Slack channel ID (e.g., C1234567890)
  name           String
  timezone       String
  createdBy      User?        @relation("TeamCreatedBy", fields: [createdByUserId], references: [id], onDelete: SetNull)
  createdByUserId String?
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  // Relations
  members        TeamMember[]
  configs        StandupConfig[]
  instances      StandupInstance[]

  @@index([integrationId, slackChannelId])
  @@index([orgId, createdAt])
  @@unique([integrationId, slackChannelId])
}

model TeamMember {
  id                String           @id @default(uuid())
  team              Team             @relation(fields: [teamId], references: [id], onDelete: Cascade)
  teamId            String
  platformUserId    String?          // Legacy field - keeping for backward compatibility
  integrationUser   IntegrationUser? @relation("IntegrationUserTeamMember", fields: [integrationUserId], references: [id], onDelete: SetNull)
  integrationUserId String?          // Reference to IntegrationUser
  user              User?            @relation("TeamMemberUser", fields: [userId], references: [id], onDelete: SetNull)
  userId            String?
  name              String?
  active            Boolean          @default(true)
  addedBy           User?            @relation("TeamMemberAddedBy", fields: [addedByUserId], references: [id], onDelete: SetNull)
  addedByUserId     String?
  addedAt           DateTime         @default(now())

  // Relations
  configMemberships StandupConfigMember[]
  answers           Answer[]

  @@unique([teamId, platformUserId])
  @@unique([teamId, userId], map: "unique_team_user")
  @@index([teamId, addedAt])
}

model StandupConfig {
  id                     String        @id @default(uuid())
  team                   Team          @relation(fields: [teamId], references: [id], onDelete: Cascade)
  teamId                 String        @unique // Only one config per team
  questions              String[]
  weekdays               Int[]         // 0 = Sunday
  timeLocal              String
  timezone               String
  reminderMinutesBefore  Int           @default(10)
  responseTimeoutHours   Int           @default(2)
  isActive               Boolean       @default(true)
  createdBy              User?         @relation("StandupConfigCreatedBy", fields: [createdByUserId], references: [id], onDelete: SetNull)
  createdByUserId        String?
  createdAt              DateTime      @default(now())
  updatedAt              DateTime      @updatedAt

  // Relations
  configMembers          StandupConfigMember[]
}

model StandupConfigMember {
  standupConfig    StandupConfig @relation(fields: [standupConfigId], references: [id], onDelete: Cascade)
  standupConfigId  String
  teamMember       TeamMember    @relation(fields: [teamMemberId], references: [id], onDelete: Cascade)
  teamMemberId     String
  include          Boolean
  role             String?       // Optional role (e.g., "lead", "member")
  updatedAt        DateTime      @updatedAt

  @@id([standupConfigId, teamMemberId])
}

enum StandupInstanceState {
  pending
  collecting
  posted
}

model StandupInstance {
  id             String       @id @default(uuid())
  team           Team         @relation(fields: [teamId], references: [id], onDelete: Cascade)
  teamId         String
  configSnapshot Json         // frozen copy at creation
  targetDate     DateTime
  state          StandupInstanceState
  createdAt      DateTime     @default(now())
  
  // Slack message tracking
  reminderMessageTs String?    // Timestamp of initial reminder message
  summaryMessageTs  String?    // Timestamp of summary message

  // Relations
  digestPost     StandupDigestPost?
  answers        Answer[]
  participationSnapshots ParticipationSnapshot[]

  @@index([teamId, targetDate])
}

model StandupDigestPost {
  standupInstance    StandupInstance @relation(fields: [standupInstanceId], references: [id], onDelete: Cascade)
  standupInstanceId  String          @unique
  integration        Integration     @relation(fields: [integrationId], references: [id], onDelete: Cascade)
  integrationId      String
  channelId          String
  messageTs          String

  @@id([standupInstanceId])
}

model Answer {
  standupInstance   StandupInstance @relation(fields: [standupInstanceId], references: [id], onDelete: Cascade)
  standupInstanceId String
  teamMember        TeamMember      @relation(fields: [teamMemberId], references: [id], onDelete: Cascade)
  teamMemberId      String
  questionIndex     Int
  text              String
  submittedAt       DateTime        @default(now())

  @@id([standupInstanceId, teamMemberId, questionIndex])
  @@index([teamMemberId])
}

model ParticipationSnapshot {
  id                  String           @id @default(uuid())
  standupInstance     StandupInstance  @relation(fields: [standupInstanceId], references: [id], onDelete: Cascade)
  standupInstanceId   String
  answersCount        Int
  membersMissing      Int
}

// ------------------------------
// BILLING MODELS
// ------------------------------
model BillingAccount {
  id                   String          @id @default(uuid())
  org                  Organization    @relation(fields: [orgId], references: [id], onDelete: Cascade)
  orgId                String          @unique
  stripeCustomerId     String
  billingEmail         String?
  defaultPaymentMethod String?
  taxId                String?
  country              String?

  // Relations
  subscription         Subscription?
}
enum SubscriptionStatus {
  trialing
  active
  past_due
  canceled
}

model Subscription {
  id                    String           @id @default(uuid())
  billingAccount        BillingAccount   @relation(fields: [billingAccountId], references: [id], onDelete: Cascade)
  billingAccountId      String           @unique
  stripeSubscriptionId  String
  plan                  String
  memberQuota           Int
  status                SubscriptionStatus
  renewsAt              DateTime

  // Relations
  events                SubscriptionEvent[]
  planHistory           PlanHistory[]

  @@index([status])
  @@index([renewsAt])
}

model SubscriptionEvent {
  id             String       @id @default(uuid())
  subscription   Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  subscriptionId String
  kind           String       // e.g. invoice.paid
  payload        Json
  createdAt      DateTime     @default(now())
}

model PlanHistory {
  subscription     Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  subscriptionId   String
  validFrom        DateTime
  plan             String
  memberQuota      Int

  @@id([subscriptionId, validFrom])
}

// ------------------------------
// OPERATIONAL HOUSEKEEPING
// ------------------------------
model TokenRefreshJob {
  id              String      @id @default(uuid())
  integration     Integration @relation(fields: [integrationId], references: [id], onDelete: Cascade)
  integrationId   String
  scheduledAt     DateTime
  status          String
  lastAttemptAt   DateTime?
  errorMsg        String?

  @@index([integrationId])
}
model WebhookFailure {
  id            String   @id @default(uuid())
  webhookType   String
  payload       Json
  retryCount    Int      @default(0)
  lastErrorMsg  String?
  createdAt     DateTime @default(now())
}
