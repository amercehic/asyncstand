generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ------------------------------
// USER AUTHENTICATION & TENANCY (Multi-Tenant Model)
// ------------------------------
model User {
  id                         String       @id @default(uuid())
  email                      String       @unique
  passwordHash               String
  name                       String?
  twofaSecret                String?
  isSuperAdmin               Boolean      @default(false)
  createdAt                  DateTime     @default(now())
  updatedAt                  DateTime     @updatedAt

  // Relations
  passwordResetTokens        PasswordResetToken[]
  sessions                   Session[]
  refreshTokens              RefreshToken[]
  orgMembers                 OrgMember[]
  invitedMembers             OrgMember[]      @relation("InvitedBy")
  auditLogs                  AuditLog[]       @relation("AuditLogActor")
  integrationsInstalled      Integration[]    @relation("IntegrationInstalledBy")
  teamMembers                TeamMember[]     @relation("TeamMemberUser")
  createdTeams               Team[]           @relation("TeamCreatedBy")
  addedTeamMembers           TeamMember[]     @relation("TeamMemberAddedBy")
  createdStandupConfigs      StandupConfig[]  @relation("StandupConfigCreatedBy")

  // Performance indexes
  @@index([email, createdAt])
  @@index([createdAt])
}

model PasswordResetToken {
  token     String   @id @default(uuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  expiresAt DateTime

  @@index([token])
}

model Session {
  id          String   @id @default(uuid())
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  issuedAt    DateTime @default(now())
  lastSeenIp  String?
  revokedAt   DateTime?

  @@index([userId, issuedAt])
  @@index([revokedAt])
}

/// Refresh tokens for rotation, anomaly detection, and per-device session control
model RefreshToken {
  id          String   @id @default(uuid())
  token       String   @unique
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  createdAt   DateTime @default(now())
  lastUsedAt  DateTime?
  revokedAt   DateTime?
  fingerprint String
  ipAddress   String

  @@index([userId, createdAt])
}

model Organization {
  id               String           @id @default(uuid())
  name             String?
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt

  // Relations
  billingAccount   BillingAccount?
  members          OrgMember[]
  integrations     Integration[]
  teams            Team[]
  auditLogs        AuditLog[]
  featureOverrides FeatureOverride[]
}

enum OrgRole {
  owner
  admin
  member
}

enum OrgMemberStatus {
  invited
  active
  suspended
}

model OrgMember {
  org          Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  orgId        String
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId       String
  role         OrgRole
  status       OrgMemberStatus
  inviteToken  String?      @unique
  invitedAt    DateTime?
  invitedBy    User?        @relation("InvitedBy", fields: [invitedById], references: [id], onDelete: SetNull)
  invitedById  String?
  acceptedAt   DateTime?

  @@id([orgId, userId])
  @@unique([orgId, userId])
  @@index([inviteToken])
}

model AuditLog {
  id                    String       @id @default(uuid())
  org                   Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  orgId                 String
  actorUser             User?        @relation("AuditLogActor", fields: [actorUserId], references: [id])
  actorUserId           String?
  actorPlatformUserId   String?
  actorType             String       @default("user") // user, system, api_key, service
  
  // Event classification
  action                String
  category              String       // auth, user_management, data_modification, system, integration, billing
  severity              String       // low, medium, high, critical
  
  // Request/Response data
  requestData           Json?        // Method, path, body, query, headers, userAgent, ipAddress
  responseData          Json?        // StatusCode, body, executionTime
  
  // Resource tracking
  resources             Json?        // Array of affected resources with before/after values
  
  // Enhanced metadata
  sessionId             String?
  correlationId         String?
  tags                  String[]     @default([])
  executionTime         Int?         // Milliseconds
  
  // Legacy payload field (for backward compatibility)
  payload               Json?
  
  createdAt             DateTime     @default(now())

  @@index([orgId, createdAt])
  @@index([orgId, category, createdAt])
  @@index([orgId, severity, createdAt])
  @@index([orgId, actorUserId, createdAt])
  @@index([correlationId])
  @@index([sessionId])
}

// ------------------------------
// EXTERNAL PLATFORM INTEGRATIONS
// ------------------------------
enum IntegrationPlatform {
  slack
  teams
}

enum TokenStatus {
  ok
  expired
  revoked
}

model Integration {
  id                String        @id @default(uuid())
  org               Organization  @relation(fields: [orgId], references: [id], onDelete: Cascade)
  orgId             String
  platform          IntegrationPlatform
  externalTeamId    String
  accessToken       String
  refreshToken      String?
  expiresAt         DateTime?
  tokenStatus       TokenStatus
  scopes            String[]      // Bot scopes granted to the bot token
  userScopes        String[]      @default([]) // User scopes granted to the user token
  installedBy       User?         @relation("IntegrationInstalledBy", fields: [installedByUserId], references: [id], onDelete: SetNull)
  installedByUserId String?
  
  // Slack-specific OAuth v2 fields
  botToken          String?
  botUserId         String?
  appId             String?

  // Relations
  teams             Team[]
  channels          Channel[]
  integrationUsers  IntegrationUser[]
  syncState         IntegrationSyncState?
  digestPosts       StandupDigestPost[]
  tokenRefreshJobs  TokenRefreshJob[]

  @@unique([orgId, platform, externalTeamId])
  @@index([tokenStatus])
  @@index([orgId, platform])
  @@index([orgId, tokenStatus])
  @@index([expiresAt])
}

model IntegrationSyncState {
  integration        Integration @relation(fields: [integrationId], references: [id], onDelete: Cascade)
  integrationId      String      @id
  lastUsersSyncAt    DateTime?
  lastChannelsSyncAt DateTime?
  errorMsg           String?
}

// ------------------------------
// STANDUP FEATURE DOMAINS
// ------------------------------
model Channel {
  id             String       @id @default(uuid())
  integration    Integration  @relation(fields: [integrationId], references: [id], onDelete: Cascade)
  integrationId  String
  channelId      String       // Slack channel ID (e.g., C1234567890)
  name           String       // Channel name (e.g., engineering)
  topic          String?      // Channel topic/description
  purpose        String?      // Channel purpose
  isPrivate      Boolean      @default(false)
  isArchived     Boolean      @default(false)
  memberCount    Int?         // Number of members in channel
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  lastSyncAt     DateTime?    // When channel info was last synced

  // Relations
  standupConfigs StandupConfig[] // Standup configs that target this channel

  @@unique([integrationId, channelId])
  @@index([integrationId, isArchived])
  @@index([name])
}

model IntegrationUser {
  id              String      @id @default(uuid())
  integration     Integration @relation(fields: [integrationId], references: [id], onDelete: Cascade)
  integrationId   String
  
  // Generic fields that work for all platforms (Slack, Teams, Discord, etc.)
  externalUserId  String      // Slack ID, Teams ID, Discord ID, etc.
  name            String?
  displayName     String?
  email           String?
  isBot           Boolean     @default(false)
  isDeleted       Boolean     @default(false)
  profileImage    String?
  timezone        String?
  
  // Platform-specific data stored as JSON
  platformData    Json?       // Store platform-specific fields here
  
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  lastSyncAt      DateTime?

  // Relations
  teamMembers     TeamMember[] @relation("IntegrationUserTeamMember")

  @@unique([integrationId, externalUserId])
  @@index([integrationId, isDeleted])
  @@index([integrationId, externalUserId])
  @@index([email])
  @@index([isDeleted, isBot])
}

model Team {
  id             String       @id @default(uuid())
  org            Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  orgId          String
  integration    Integration  @relation(fields: [integrationId], references: [id], onDelete: Cascade)
  integrationId  String
  name           String
  timezone       String
  createdBy      User?        @relation("TeamCreatedBy", fields: [createdByUserId], references: [id], onDelete: SetNull)
  createdByUserId String?
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  // Relations
  members        TeamMember[]
  configs        StandupConfig[]
  instances      StandupInstance[]

  @@unique([orgId, name])
  @@index([integrationId])
  @@index([orgId, createdAt])
}

model TeamMember {
  id                String           @id @default(uuid())
  team              Team             @relation(fields: [teamId], references: [id], onDelete: Cascade)
  teamId            String
  platformUserId    String?          // Legacy field - keeping for backward compatibility
  integrationUser   IntegrationUser? @relation("IntegrationUserTeamMember", fields: [integrationUserId], references: [id], onDelete: SetNull)
  integrationUserId String?          // Reference to IntegrationUser
  user              User?            @relation("TeamMemberUser", fields: [userId], references: [id], onDelete: SetNull)
  userId            String?
  name              String?
  active            Boolean          @default(true)
  addedBy           User?            @relation("TeamMemberAddedBy", fields: [addedByUserId], references: [id], onDelete: SetNull)
  addedByUserId     String?
  addedAt           DateTime         @default(now())

  // Relations
  configMemberships StandupConfigMember[]
  answers           Answer[]

  @@unique([teamId, platformUserId])
  @@unique([teamId, userId], map: "unique_team_user")
  @@index([teamId, addedAt])
  @@index([integrationUserId])
  @@index([platformUserId])
  @@index([userId, teamId])
  @@index([active, teamId])
}

model StandupConfig {
  id                     String               @id @default(uuid())
  team                   Team                 @relation(fields: [teamId], references: [id], onDelete: Cascade)
  teamId                 String               // Allow multiple configs per team
  name                   String               // Name to distinguish multiple configs
  deliveryType           StandupDeliveryType  @default(channel)
  targetChannel          Channel?             @relation(fields: [targetChannelId], references: [id], onDelete: SetNull)
  targetChannelId        String?              // For channel-based standups
  questions              String[]
  weekdays               Int[]                // 0 = Sunday
  timeLocal              String
  timezone               String
  reminderMinutesBefore  Int                  @default(10)
  responseTimeoutHours   Int                  @default(2)
  isActive               Boolean              @default(true)
  createdBy              User?                @relation("StandupConfigCreatedBy", fields: [createdByUserId], references: [id], onDelete: SetNull)
  createdByUserId        String?
  createdAt              DateTime             @default(now())
  updatedAt              DateTime             @updatedAt

  // Relations
  configMembers          StandupConfigMember[]

  @@index([targetChannelId])
  @@index([teamId, isActive])
  @@index([deliveryType, isActive])
  @@index([timezone, isActive])
  @@index([teamId, createdAt])
}

model StandupConfigMember {
  standupConfig    StandupConfig @relation(fields: [standupConfigId], references: [id], onDelete: Cascade)
  standupConfigId  String
  teamMember       TeamMember    @relation(fields: [teamMemberId], references: [id], onDelete: Cascade)
  teamMemberId     String
  include          Boolean
  role             String?       // Optional role (e.g., "lead", "member")
  updatedAt        DateTime      @updatedAt

  @@id([standupConfigId, teamMemberId])
}

enum StandupDeliveryType {
  channel
  direct_message
}

enum StandupInstanceState {
  pending
  collecting
  posted
}

model StandupInstance {
  id             String       @id @default(uuid())
  team           Team         @relation(fields: [teamId], references: [id], onDelete: Cascade)
  teamId         String
  configSnapshot Json         // frozen copy at creation
  targetDate     DateTime
  state          StandupInstanceState
  createdAt      DateTime     @default(now())
  
  // Slack message tracking
  reminderMessageTs String?    // Timestamp of initial reminder message
  summaryMessageTs  String?    // Timestamp of summary message

  // Relations
  digestPost     StandupDigestPost?
  answers        Answer[]
  participationSnapshots ParticipationSnapshot[]

  @@index([teamId, targetDate])
  @@index([state, targetDate])
  @@index([teamId, state])
  @@index([targetDate, state])
}

model StandupDigestPost {
  standupInstance    StandupInstance @relation(fields: [standupInstanceId], references: [id], onDelete: Cascade)
  standupInstanceId  String          @unique
  integration        Integration     @relation(fields: [integrationId], references: [id], onDelete: Cascade)
  integrationId      String
  channelId          String
  messageTs          String

  @@id([standupInstanceId])
}

model Answer {
  standupInstance   StandupInstance @relation(fields: [standupInstanceId], references: [id], onDelete: Cascade)
  standupInstanceId String
  teamMember        TeamMember      @relation(fields: [teamMemberId], references: [id], onDelete: Cascade)
  teamMemberId      String
  questionIndex     Int
  text              String
  submittedAt       DateTime        @default(now())

  @@id([standupInstanceId, teamMemberId, questionIndex])
  @@index([teamMemberId])
  @@index([standupInstanceId, submittedAt])
  @@index([teamMemberId, submittedAt])
}

model ParticipationSnapshot {
  id                  String           @id @default(uuid())
  standupInstance     StandupInstance  @relation(fields: [standupInstanceId], references: [id], onDelete: Cascade)
  standupInstanceId   String
  answersCount        Int
  membersMissing      Int
}

// ------------------------------
// BILLING MODELS
// ------------------------------
model BillingAccount {
  id                   String          @id @default(uuid())
  org                  Organization    @relation(fields: [orgId], references: [id], onDelete: Cascade)
  orgId                String          @unique
  stripeCustomerId     String
  billingEmail         String?
  defaultPaymentMethod String?
  taxId                String?
  country              String?

  // Relations
  subscription         Subscription?
}
enum SubscriptionStatus {
  trialing
  active
  past_due
  canceled
}

model Plan {
  id            String   @id @default(uuid())
  key           String   @unique // "free", "starter", "professional", "enterprise"
  name          String   // "Free Plan"
  displayName   String   // "Free"
  description   String?  // "Perfect for small teams"
  price         Decimal  // Monthly price in cents
  interval      String   @default("month") // "month" or "year"
  stripePriceId String?  // Stripe price ID
  isActive      Boolean  @default(true)
  sortOrder     Int      @default(0)
  
  // Quotas and limits (null = unlimited)
  memberLimit      Int?
  teamLimit        Int?
  standupLimit     Int?     // per month
  storageLimit     Int?     // in MB
  integrationLimit Int?
  
  // Relations
  features      PlanFeature[]
  subscriptions Subscription[]
  planHistory   PlanHistory[]
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@index([isActive, sortOrder])
}

model PlanFeature {
  id          String @id @default(uuid())
  plan        Plan   @relation(fields: [planId], references: [id], onDelete: Cascade)
  planId      String
  feature     Feature @relation(fields: [featureKey], references: [key])
  featureKey  String
  enabled     Boolean @default(true)
  value       String? // For features with specific values
  
  @@unique([planId, featureKey])
  @@index([featureKey])
}

// Global feature flags for development, A/B testing, gradual rollout
model Feature {
  key           String   @id // "new_ui", "advanced_analytics", "beta_feature"
  name          String   // Human-readable name
  description   String?  // What this feature does
  
  // Feature availability controls
  isEnabled     Boolean  @default(false) // Global kill switch
  environment   String[] @default([]) // ["development", "staging", "production"]
  
  // Rollout configuration
  rolloutType   String   @default("boolean") // "boolean", "percentage", "user_list", "org_list"
  rolloutValue  Json?    // Percentage, user IDs, org IDs, etc.
  
  // Feature metadata
  category      String?  // "billing", "ui", "experimental", "integration"
  isPlanBased   Boolean  @default(false) // Whether this requires a specific plan
  requiresAdmin Boolean  @default(false) // Whether only admins can use this
  
  // Relations
  planFeatures  PlanFeature[]
  orgOverrides  FeatureOverride[]
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@index([isEnabled, environment])
  @@index([category])
}

// Organization-specific feature overrides
model FeatureOverride {
  id          String   @id @default(uuid())
  org         Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  orgId       String
  feature     Feature @relation(fields: [featureKey], references: [key])
  featureKey  String
  enabled     Boolean // Override the default feature state for this org
  value       String? // Custom value for this org
  reason      String? // Why this override exists
  expiresAt   DateTime? // Temporary overrides (e.g., beta access)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@unique([orgId, featureKey])
  @@index([orgId])
  @@index([featureKey])
  @@index([expiresAt])
}

model Subscription {
  id                    String           @id @default(uuid())
  billingAccount        BillingAccount   @relation(fields: [billingAccountId], references: [id], onDelete: Cascade)
  billingAccountId      String           @unique
  stripeSubscriptionId  String?
  plan                  Plan             @relation(fields: [planId], references: [id])
  planId                String
  status                SubscriptionStatus
  renewsAt              DateTime

  // Relations
  events                SubscriptionEvent[]
  planHistory           PlanHistory[]

  @@index([status])
  @@index([renewsAt])
  @@index([planId])
}

model SubscriptionEvent {
  id             String       @id @default(uuid())
  subscription   Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  subscriptionId String
  kind           String       // e.g. invoice.paid
  payload        Json
  createdAt      DateTime     @default(now())
}

model PlanHistory {
  subscription     Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  subscriptionId   String
  validFrom        DateTime
  plan             Plan         @relation(fields: [planId], references: [id])
  planId           String

  @@id([subscriptionId, validFrom])
  @@index([planId])
}

// ------------------------------
// OPERATIONAL HOUSEKEEPING
// ------------------------------
model TokenRefreshJob {
  id              String      @id @default(uuid())
  integration     Integration @relation(fields: [integrationId], references: [id], onDelete: Cascade)
  integrationId   String
  scheduledAt     DateTime
  status          String
  lastAttemptAt   DateTime?
  errorMsg        String?

  @@index([integrationId])
}
model WebhookFailure {
  id            String   @id @default(uuid())
  webhookType   String
  payload       Json
  retryCount    Int      @default(0)
  lastErrorMsg  String?
  createdAt     DateTime @default(now())
}
